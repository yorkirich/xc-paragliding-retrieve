<!DOCTYPE html>
<html>
<head>
    <title>XCTrack Retrieve Planner</title>
    <style>
        /* ----------------------------------------------------- */
        /* OPTIMIZED STYLES FOR XCTRACK/COMPCHECK LOOK AND FEEL */
        /* ----------------------------------------------------- */
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center;     /* Center vertically */
            min-height: 100vh;       /* Ensure body takes full viewport height */
        }
        #results-container {
            width: 90vw; /* Use a relative width for large screen area */
            max-width: 400px; /* Maximize font size but keep constrained */
            padding: 10px;
            text-align: center;
        }

        /* Styling for the main output grid (TDP1 and TDP2) */
        .output-grid {
            display: grid;
            /* Define 3 columns for Value, Unit/Mode, Time/Direction */
            grid-template-columns: 1fr 0.5fr 1fr; 
            gap: 1px; /* Grid line thickness */
            background-color: #333; /* Dark color for grid lines */
            color: #000;
            border: 1px solid #333;
        }

        .grid-cell {
            background-color: #fff; /* White cell background */
            padding: 5px 0;
            text-align: center;
            /* Enforce specific font sizes for readability */
        }

        /* Large font for distance/time/mode */
        .value-large {
            font-size: 3em; /* Very large font for primary numbers */
            font-weight: bold;
            line-height: 1.1;
        }

        /* Medium font for units (km, SE) */
        .value-medium {
            font-size: 1.5em; /* Medium font for units and direction */
            line-height: 1.1;
        }

        /* Error/Status messages */
        #status-error {
            color: #dc3545;
            font-weight: bold;
            font-size: 1.2em;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="results-container">
        <div id="status-error" style="display:none;"></div> 
        <div id="results" class="output-grid">
            </div>
    </div>

    <script>
        // =========================================================================
        // XCTrack Paraglider Retrieve Planner Script (Consolidated Logic)
        // With Console Debugging and Optimized Layout Logic
        // =========================================================================

        let DESTINATION_INPUT = '';
        let TRAVEL_MODE; 

        // --- Helper to format output time (hh:mm) from timestamp (seconds) ---
        function timestampToHHMM(timestamp) {
            // value is in seconds, so convert to milliseconds
            const date = new Date(timestamp * 1000); 
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // --- 1. Function to parse URL parameters ---
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' ')).trim();
        }
        
        // --- 2. Calculate Distance and Direction (Haversine/Bearing) ---
        function calculateDistanceAndDirection(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in km
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            lat1 = lat1 * (Math.PI / 180);
            lat2 = lat2 * (Math.PI / 180);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distanceKm = R * c; 
            
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let bearing = Math.atan2(y, x) * (180 / Math.PI);
            
            bearing = (bearing + 360) % 360; 

            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const direction = directions[Math.round(bearing / 45) % 8];

            // Distance as a number for large display, and unit for small display
            const distanceNum = distanceKm.toFixed(1);

            return {
                distanceNum: distanceNum,
                unit: 'km',
                direction: direction
            };
        }

        // --- 3. Helper to format the optimized grid cells ---
        function createGridCells(value1, unit1, value2, unit2, value3, unit3) {
            return `
                <div class="grid-cell value-large">${value1}</div>
                <div class="grid-cell value-medium">${unit1}</div>
                <div class="grid-cell value-large">${value2}</div>
                
                <div class="grid-cell value-large">${unit2}</div>
                <div class="grid-cell value-large">${value3}</div>
                <div class="grid-cell value-large">${unit3}</div>
            `;
        }
        
        // --- 4. Core Logic: Process API Steps and Display ---
        function processSteps(currentLat, currentLon, steps, overallArrivalTime) {
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = ''; // Clear results

            if (TRAVEL_MODE === google.maps.TravelMode.TRANSIT) {
                const transportSteps = steps.filter(step => step.travel_mode === google.maps.TravelMode.TRANSIT.toUpperCase());
                
                const tdp1Step = transportSteps[0];
                const tdp2Step = transportSteps[1];
                
                // TDP 1
                if (tdp1Step && tdp1Step.transit) {
                    const details = tdp1Step.transit;
                    const tdp1Loc = details.departure_stop.location;
                    
                    const { distanceNum, unit, direction } = calculateDistanceAndDirection(
                        currentLat, currentLon, tdp1Loc.lat(), tdp1Loc.lng()
                    );
                    
                    const departureTime = timestampToHHMM(details.departure_time.value);
                    const vehicleType = details.line.vehicle.type.substring(0,4).toUpperCase().trim(); // BUS, RAIL, TRAM, etc.

                    // Row 1: Distance | km | SE
                    // Row 2: BUS/RAIL | 07:20 (Departure Time) | (empty)
                    resultsContainer.innerHTML += createGridCells(
                        distanceNum, unit, direction,
                        vehicleType, departureTime, ''
                    );
                }
                
                // Separator/Spacer Row (If both TDPs exist, or if we want a line)
                if (tdp1Step && tdp2Step) {
                    resultsContainer.innerHTML += `<div class="grid-cell" style="grid-column: 1 / span 3; padding: 1px; background-color: #f4f4f9;"></div>`;
                }
                
                // TDP 2
                if (tdp2Step && tdp2Step.transit) {
                    const details = tdp2Step.transit;
                    const tdp2Loc = details.departure_stop.location;

                    const { distanceNum, unit, direction } = calculateDistanceAndDirection(
                        currentLat, currentLon, tdp2Loc.lat(), tdp2Loc.lng()
                    );
                    
                    const departureTime = timestampToHHMM(details.departure_time.value);
                    const vehicleType = details.line.vehicle.type.substring(0,4).toUpperCase().trim();

                    // Row 3: Distance | km | E
                    // Row 4: RAIL | 05:00 (Departure Time) | (empty)
                    resultsContainer.innerHTML += createGridCells(
                        distanceNum, unit, direction,
                        vehicleType, departureTime, ''
                    );
                }

                // Final Row: Total Arrival Time
                resultsContainer.innerHTML += `
                    <div class="grid-cell value-large" style="grid-column: 1 / span 2;">ARR</div>
                    <div class="grid-cell value-large">${overallArrivalTime}</div>
                `;
                
                if (!tdp1Step && !tdp2Step) {
                    document.getElementById('status-error').style.display = 'block';
                    document.getElementById('status-error').innerText = 'NO TRANSIT FOUND.';
                }

            } else {
                // Non-Transit Mode: Hide the grid, show a simple error (as requested to focus on TDPs)
                document.getElementById('status-error').style.display = 'block';
                document.getElementById('status-error').innerText = 'SUCCESS. Switch to &mode=transit for TDP display.';
            }
        }

        // --- 5. Core: Call the DirectionsService API ---
        function calculateRetrieveRoute(currentLat, currentLon) {
            const directionsService = new google.maps.DirectionsService();
            
            const request = {
                origin: { lat: currentLat, lng: currentLon },
                destination: DESTINATION_INPUT,
                travelMode: TRAVEL_MODE,
            };
            
            if (TRAVEL_MODE === google.maps.TravelMode.TRANSIT) {
                request.transitOptions = {
                    departureTime: new Date()
                };
            }
            
            directionsService.route(request, (response, status) => {
                // *** DEBUGGING: LOG THE FULL RESPONSE TO CONSOLE ***
                console.log("--- Google Maps Directions API Response ---");
                console.log("Status:", status);
                console.log("Full Response Object:", response);
                console.log("-----------------------------------------");
                
                if (status === 'OK') {
                    const bestRoute = response.routes[0].legs[0]; 
//                    const overallArrivalTime = timestampToHHMM(bestRoute.arrival_time.value);
                    const overallArrivalTime = bestRoute.arrival_time.text;
                    
                    processSteps(currentLat, currentLon, bestRoute.steps, overallArrivalTime);
                    
                } else {
                    document.getElementById('status-error').style.display = 'block';
                    document.getElementById('status-error').innerText = `API FAILED: ${status}`;
                }
            });
        }

        // --- 6. Main Execution Flow (The Callback Function) ---
        window.initRetrieve = function() {
            TRAVEL_MODE = google.maps.TravelMode.TRANSIT; 
            
            DESTINATION_INPUT = getUrlParameter('dest');
            const modeParam = getUrlParameter('mode').toUpperCase(); 
            
            if (modeParam && google.maps.TravelMode[modeParam]) {
                TRAVEL_MODE = google.maps.TravelMode[modeParam];
            }
            
            if (!DESTINATION_INPUT) {
                document.getElementById('status-error').style.display = 'block';
                document.getElementById('status-error').innerText = "ERROR: Missing 'dest' parameter.";
                return; 
            }

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        calculateRetrieveRoute(lat, lon);
                    },
                    (error) => {
                        document.getElementById('status-error').style.display = 'block';
                        document.getElementById('status-error').innerText = `LOCATION ERROR: ${error.message}.`;
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            } else {
                document.getElementById('status-error').style.display = 'block';
                document.getElementById('status-error').innerText = "ERROR: Geolocation not supported.";
            }
        }
    </script>
    
    <script>
        const apiKey = getUrlParameter('key');
        const script = document.createElement('script');
        
        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initRetrieve&libraries=places`;
        script.defer = true;
        script.async = true; 
        document.head.appendChild(script);

    </script>
</body>
</html>
